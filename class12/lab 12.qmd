---
title: "lab 12 Norman Lee "
Author: "Norman Lee A18086849"
format: html
editor: 
  markdown: 
    wrap: sentence
---

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

> Q1.
> How many genes are in this dataset?

38694

\>Q2.
How many ‘control’ cell lines do we have?

4

```{r}
metadata$id == colnames(counts)
```

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

> Q3.
> How would you make the above code in either approach more robust?
> Is there a function that could help here?
> **rowMeans** Q4.
> Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts[, treated$id]
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> 5a

```{r}
plot(meancounts[,1], meancounts[,2], xlab="Control", ylab="Treated")
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below.
> What geom\_?(
> ) function would you use for this plot?

```{r}
library(ggplot2)
ggplot(meancounts)+
  aes(control.mean, treated.mean)+
  geom_point()
```

> Q6.
> Try plotting both axes on a log scale.
> What is the argument to plot() that allows you to do this?
> log="xy"

```{r}
plot(meancounts[,1], meancounts[,2], log = "xy")

```

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q7.
> What is the purpose of the arr.ind argument in the which() function call above?
> Why would we then take the first column of the output and need to call the unique() function?
> *which(..., arr.ind = TRUE) gives both row and column positions of all zeros. Unique() removes duplicates (in case a row has zeros in both columns) This ensures that any genes with zero mean counts (in either control or treated) are excluded*

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

> Q8.
> Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?
> *250*

> Q9.
> Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?
> *367*

> Q10.
> Do you trust these results?
> Why or why not?
> These results are based only on log₂ fold change thresholds (\>\|2\|), not on statistical testing.
> *Some genes might appear strongly up- or down-regulated by chance, due to biological or technical variability.We haven’t computed p-values*

```{r}
library(DESeq2)

dds<- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

```{r}
dds <- DESeq(dds)
```

```{r}
res<- results(dds)
res
```

```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```

```{r}
#columns(org.Hs.eg.db)
```

```{r}
#res$symbol <- mapIds(org.Hs.eg.db,
                     #keys=row.names(res), # Our genenames
                     ##keytype="ENSEMBL",        # The format of our genenames
                     #column="SYMBOL",          # The new format we want to add
                     #multiVals="first")

#head(res)
```

Q11.
Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res\$genename.

```{r}
#res$entrez <- mapIds(org.Hs.eg.db,
                    # keys=row.names(res),
                    # column="ENTREZID",
                    # keytype="ENSEMBL",
                    # multiVals="first")

#res$uniprot <- mapIds(org.Hs.eg.db,
                  #   keys=row.names(res),
                   #  column="UNIPROT",
                    # keytype="ENSEMBL",
                    # multiVals="first")

#res$genename <- mapIds(org.Hs.eg.db,
                 #    keys=row.names(res),
                    # column="GENENAME",
                #     keytype="ENSEMBL",
                   #  multiVals="first")

#head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
write.csv(res[ord,], "deseq_results.csv")
```

#volcano plot

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```
